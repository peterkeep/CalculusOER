<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-RiemannSums" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Riemann Sums and Area Approximations</title>

  <introduction>
    <p>
      One of the last things we said in <xref ref="sec-IndefiniteIntegrals"/> was that antiderivatives will be connected to areas. We're going to eventually show this! For now, though, we want to focus on areas defined by curves. 
    </p>
    <xi:include href="./activities/act-ApproximatingArea.ptx" />
    <p>
      Hopefully we've had a chance to think about and compare a couple of different strategies for estimating this area. What we want to do, though, is build a systematic way of estimating this area. We'd like it to have a couple of features:
      <ul>
        <li>
          <p>
            Easy area calculations. We don't want to have to spend a lot of time thinking about tricky area formulas, so simple shapes will be nicer to use.
          </p>
        </li>
        <li>
          <p>
            Flexibility. We want to be able to apply our approach to an area defined by any curve.
            <aside>
              <p>
                This is the problem with Archimedes' method: it only worked for areas defined by parabolas. Once we change our function to something else, Archimedes would have to come up with a completely new area formula for calculation. The techniques we're looking at now have the advantage of flexibility!
              </p>
            </aside>
          </p>
        </li>
        <li>
          <p>
            Precision. We want to be able to make our estimates as precise as we'd like. It's fine to come up with rough estimates, but we would like a method that allows us to increase the accuracy in our estimations.
          </p>
        </li>
      </ul>
    </p>
  </introduction>

  <subsection xml:id="subsec-RectangularApproximations">
    <title>Rectangular Approximations</title>
    <p>
      We're going to re-visit the same region as before, but this time we'll outline a process that should help us approximate the area with as much precision as we'd like.
    </p>
    <xi:include href="./activities/act-RectangularApproximation.ptx" />
    <p>
      This is our process! We'll refer to it often as the <term>slice-and-sum process</term>, since we are slicing out region into a bunch of pieces, approximating the area on each piece (by using one point to represent the whole slice), and then summing the areas back up.
    </p>
    <p>
      More formally, we can call this the Riemann Sum process, because the sum of the areas is a special form of summation.
    </p>
    <definition xml:id="def-RiemannSum">
      <title>Riemann Sum</title>
      <statement>
        <p>
          For a closed interval <m>[a,b]</m> with a partition <m>\{x_0, x_1, ..., x_n\}</m> with <m>a=x_0 \lt x_1\lt ...\lt x_n=b</m>, consider some <m>x_k^*</m>, any <m>x</m>-value in the interval <m>[x_{k-1}, x_k]</m> and <m>\Delta x_k</m>, the length of the interval <m>[x_{k-1}, x_k]</m>. If <m>f</m> is a function that is defined on the interval <m>[a,b]</m>, then we call the sum 
            <me>
              \sum_{k=1}^n f(x_k^*) \Delta x_k = f(x_1^*) \Delta x_1 + f(x_2^*)\Delta x_2 + ... + f(x_n^*) \Delta x_n
            </me>
            a <term>Riemann Sum</term> for <m>f</m> on <m>[a,b]</m>.
        </p>
      </statement>
    </definition>
    <note>
      <p>
        In practice, we typically choose a <em>Regular Partition</em>, where each subinterval <m>[x_{k-1}, x_k]</m> is equally-wide, and so <m>\Delta x_k = \frac{b-a}{n}</m> for every <m>k=1,2,...,n</m>. We then normally write our Riemann sum as
        <me>
          \sum_{k=1}^n f(x_k^*) \Delta x = f(x_1^*) \Delta x + f(x_2^*)\Delta x + ... + f(x_n^*) \Delta x
        </me>
        where <m>\Delta x</m> is the value of the widths of all of the equally-sized subintervals.
      </p>
    </note>
  
  </subsection>
</section>